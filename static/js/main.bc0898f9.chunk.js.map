{"version":3,"sources":["globalFunctions.js","treeTops.js","dataSets.js","generators.js","decoder.js","grass.js","App.jsx","trunk.js","island.js","rock.js","generateModel.js","index.js"],"names":["getRandomFloat","min","max","Math","random","getRandomInt","ceil","floor","updateVertices","mesh","updateMatrix","geometry","applyMatrix4","matrix","position","set","rotation","scale","getVertices","verticesArray","vertices","attributes","array","i","length","push","Vector3","convertVerticesToVectors","x","y","z","index","convertVectorsToVertices","vectorArray","sort","a","b","forEach","vector","getMatchingVertices","indexArray","verticle","generateTop","trunkTop","scene","topData","color","tipHeight","data","tipOffsetX","tipOffsetZ","segmentHeight","topOffsetX","topOffsetZ","material","MeshPhysicalMaterial","parseInt","replace","flatShading","group","Group","height","points","THREE","getPoints","previousPoint","point","item","topMesh","pointX","pointY","bottomWidth","topWidth","rotationY","lastVerticle","direction","subVectors","orientation","Matrix4","lookAt","Object3D","up","multiply","edgeGeometry","CylinderGeometry","edge","setAttribute","rotateY","cylinderMesh","bottomRadius","topRadius","needsUpdate","add","translateY","trunkColorsData","value","probability","trunkWidthData","trunkShrinkData","trunkSegmentAmountData","trunkHeightData","topColorsData","tipHeightData","tipOffsetData","topOffsetData","topAmountData","topBottomWidthData","topSegmentShrinkData","topShrinkData","topHeightData","topRotationData","generateItemFromDataset","dataArray","generatedArray","dataArrayGenerator","generate","trunkColor","trunkWidth","trunkShrink","trunkArray","segmentAmount","endPoint","pointArray","toFixed","join","trunkArrayGenerator","topColor","tipOffsetY","topArray","topSegmentShrink","topShrink","segmentArray","topArrayGenerator","stringToPointArray","string","split","map","parseFloat","seed","convertStringToData","itemArray","s","total","match","shift","convertStringToNumber","decoder","age","splitData","trunkData","width","shrink","trunkDecoder","topDecoder","totalSegmentAmount","splice","grass","ConeGeometry","Mesh","heights","filter","self","findIndex","t","indexOf","newVertices","Float32BufferAttribute","App","useState","Scene","setScene","PerspectiveCamera","window","innerWidth","innerHeight","camera","setCamera","container","useRef","growTree","start","dna","meshArray","Float32Array","noise2D","makeNoise2D","p","normalize","multiplyScalar","meshes","concat","ConvexGeometry","trunkMesh","generateTrunk","useEffect","islandMesh","radius","DodecahedronGeometry","vertexColors","flatVertices","matchingVertices","v","colors","Color","r","g","createIsland","sampler","MeshSurfaceSampler","build","tempPosition","meshPositions","treeCounter","sample","distanceTo","check","rockCounter","OctahedronGeometry","noise3D","makeNoise3D","rock","grassModels","grassCounter","clone","light","AmbientLight","intensity","directionalLight","DirectionalLight","renderer","WebGL1Renderer","alpha","setSize","current","innerHTML","appendChild","domElement","stop","controls","OrbitControls","mouseButtons","LEFT","MOUSE","ROTATE","MIDDLE","DOLLY","RIGHT","PAN","update","addEventListener","render","animate","requestAnimationFrame","image","toDataURL","console","log","generateModel","className","ref","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bc0898f9.chunk.js","sourcesContent":["import {Vector3} from \"three\";\n\nexport const getRandomFloat = (min, max) => {\n    return Math.random() * (max - min) + min\n}\n\nexport const getRandomInt = (min, max) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport const updateVertices = (mesh) => {\n    mesh.updateMatrix()\n    mesh.geometry.applyMatrix4( mesh.matrix )\n    mesh.position.set( 0, 0, 0 )\n    mesh.rotation.set( 0, 0, 0 )\n    mesh.scale.set( 1, 1, 1 )\n    mesh.updateMatrix()\n}\n\nexport const getVertices = (mesh) => {\n    let verticesArray = []\n    let vertices = mesh.geometry.attributes.position.array\n    for (let i = 0; i < (vertices.length - 1); i += 3){\n        verticesArray.push(new Vector3(vertices[i], vertices[i + 1], vertices[i + 2]))\n    }\n    return verticesArray\n}\n\nexport const convertVerticesToVectors = (verticesArray) => {\n    let vertices = []\n    for (let i = 0; i < verticesArray.length; i += 3){\n        vertices.push({x: verticesArray[i], y: verticesArray[i + 1], z: verticesArray[i + 2], index: i})\n    }\n    return vertices\n}\n\nexport const convertVectorsToVertices = (vectorArray) => {\n    let verticesArray = []\n    vectorArray.sort((a, b) => a.index > b.index ? 1 : a.index < b.index ? -1 : 0)\n    vectorArray.forEach((vector) => {\n        verticesArray.push(vector.x, vector.y, vector.z)\n    })\n    return verticesArray\n}\n\nexport const getMatchingVertices = (vertices, index) => {\n    let indexArray = []\n    vertices.forEach((verticle, i) => {\n        if (vertices[index].x === verticle.x && vertices[index].y === verticle.y && vertices[index].z === verticle.z){\n            indexArray.push(i)\n        }\n    })\n    return indexArray\n}\n\nexport const convertStringToNumber = (s) => {\n    let total = 0\n    s = s.replace(/\\s/g, '').match(/[+\\-]?([0-9\\.\\s]+)/g) || []\n    while(s.length) total += parseFloat(s.shift())\n    return total\n}\n","import {\n    CylinderGeometry,\n    Mesh,\n    Group, MeshPhysicalMaterial, Vector3, MeshBasicMaterial, Matrix4, Object3D\n} from \"three\"\nimport {convertVerticesToVectors, getMatchingVertices, convertVectorsToVertices,updateVertices} from \"./globalFunctions\"\nimport * as THREE from \"three\"\n\nconst cylinderMesh = (pointX, pointY, material, bottomWidth, topWidth, rotationY, lastVerticle, tipHeight, tipOffsetX, tipOffsetZ) => {\n    const direction = new Vector3().subVectors(pointY, pointX)\n    const orientation = new Matrix4()\n    orientation.lookAt(pointX, pointY, new Object3D().up)\n    orientation.multiply(new Matrix4().set(1, 0, 0, 0,\n        0, 0, 1, 0,\n        0, -1, 0, 0,\n        0, 0, 0, 1))\n    const edgeGeometry = new CylinderGeometry(topWidth, bottomWidth, direction.length(), 10, 2, false)\n    const edge = new THREE.Mesh(edgeGeometry, material)\n    let vertices = convertVerticesToVectors(edge.geometry.attributes.position.array)\n    vertices.sort((a, b) => a.y > b.y ? 1 : a.y < b.y ? -1 : 0)\n\n    for (let i = 0; i < 11; i += 2){\n        getMatchingVertices(vertices, i).forEach(index => {\n            vertices[index].y -= 0.7\n        })\n    }\n\n    getMatchingVertices(vertices, 20).forEach(index => {\n        vertices[index].y += 1\n    })\n\n    if (lastVerticle){\n        getMatchingVertices(vertices, 60).forEach(index => {\n            vertices[index].y += tipHeight\n            vertices[index].x += tipOffsetX\n            vertices[index].z += tipOffsetZ\n        })\n    }\n    edge.geometry.setAttribute('position', new THREE.Float32BufferAttribute(convertVectorsToVertices(vertices), 3))\n    updateVertices(edge)\n    edge.applyMatrix4(orientation)\n    edge.position.x = (pointY.x + pointX.x) / 2\n    edge.position.y = (pointY.y + pointX.y) / 2\n    edge.position.z = (pointY.z + pointX.z) / 2\n    edge.rotateY(rotationY * 0.0174532925)\n\n    updateVertices(edge)\n\n    return edge\n}\n\nexport const generateTop = (trunkTop, scene, topData) => {\n    let {color, tipHeight, data, tipOffsetX, tipOffsetZ, segmentHeight, topOffsetX, topOffsetZ} = topData\n    const material = new MeshPhysicalMaterial({color: parseInt(color.replace(\"#\",\"0x\"),16), flatShading: true})\n    const group = new Group()\n    const height = data.length * segmentHeight\n    const curve = new THREE.QuadraticBezierCurve3(\n        new THREE.Vector3( trunkTop.x, trunkTop.y, trunkTop.z ),\n        new THREE.Vector3( trunkTop.x - (topOffsetX > 1 ? -1 : topOffsetX), trunkTop.y + (height / 2), trunkTop.z - (topOffsetZ > 1 ? -1 : topOffsetZ) ),\n        new THREE.Vector3( trunkTop.x + topOffsetX, trunkTop.y + height, trunkTop.z + topOffsetZ ),\n    );\n    const points = curve.getPoints(data.length - 1);\n    let previousPoint = null\n    points.forEach((point, i) => {\n        if (previousPoint) {\n            const item = data[i]\n            const topMesh = cylinderMesh(\n                new Vector3(previousPoint.x, previousPoint.y - 0.3, previousPoint.z),\n                point, material, item.bottomRadius, item.topRadius, item.rotationY,\n                i === points.length - 1, tipHeight, tipOffsetX, tipOffsetZ)\n            updateVertices(topMesh)\n            topMesh.geometry.attributes.position.needsUpdate = true\n            group.add( topMesh );\n        }\n        previousPoint = point\n    })\n    group.translateY(-1)\n    return group\n}","export const trunkColorsData = [\n\t{value: \"#d59168\", probability: 1},\n\t{value: \"#b97952\", probability: 10},\n\t{value: \"#a46239\", probability: 10},\n\t{value: \"#6e3b1c\", probability: 100},\n\t{value: \"#4f2409\", probability: 100},\n\t{value: \"#593e30\", probability: 1000},\n\t{value: \"#52473e\", probability: 1000},\n\t{value: \"#2f1b10\", probability: 1000}\n]\n\nexport const trunkWidthData = [\n\t{value: 0.65, probability: 1},\n\t{value: 0.68, probability: 5},\n\t{value: 0.7, probability: 100},\n\t{value: 0.72, probability: 5},\n\t{value: 0.75, probability: 1},\n]\n\nexport const trunkShrinkData = [\n\t{value: 0.8, probability: 1},\n\t{value: 0.81, probability: 5},\n\t{value: 0.82, probability: 20},\n\t{value: 0.83, probability: 100},\n\t{value: 0.84, probability: 100},\n\t{value: 0.85, probability: 20}\n]\n\nexport const trunkSegmentAmountData = [\n\t{value: 4, probability: 10},\n\t{value: 5, probability: 100},\n\t{value: 6, probability: 100},\n\t{value: 7, probability: 10},\n]\n\nexport const trunkHeightData = [\n\t{value: 4, probability: 100},\n\t{value: 4.5, probability: 50},\n\t{value: 5, probability: 50}\n]\n\nexport const topColorsData = [\n\t{value: \"#b8da67\", probability: 1},\n\t{value: \"#91b341\", probability: 10},\n\t{value: \"#384d10\", probability: 10},\n\t{value: \"#2f3b17\", probability: 100},\n\t{value: \"#99b93e\", probability: 100},\n\t{value: \"#647a26\", probability: 1000},\n\t{value: \"#313b0b\", probability: 1000},\n\t{value: \"#1e2309\", probability: 1000}\n]\n\nexport const tipHeightData = [\n\t{value: 3, probability: 100},\n\t{value: 3.3, probability: 200},\n\t{value: 3.5, probability: 100},\n\t{value: 3.8, probability: 50},\n\t{value: 4, probability: 10},\n]\n\nexport const tipOffsetData = [\n\t{value: 0, probability: 50},\n\t{value: 0.1, probability: 50},\n\t{value: 0.2, probability: 50},\n\t{value: 0.3, probability: 5},\n]\n\nexport const topOffsetData = [\n\t{value: -0.8, probability: 50},\n\t{value: -0.5, probability: 50},\n\t{value: -0.3, probability: 50},\n\t{value: 0, probability: 1000},\n\t{value: 0.3, probability: 50},\n\t{value: 0.5, probability: 50},\n\t{value: 0.8, probability: 50},\n]\n\nexport const topAmountData = [\n\t{value: 3, probability: 200},\n\t{value: 4, probability: 200},\n\t{value: 5, probability: 50},\n\t{value: 6, probability: 10},\n\t{value: 7, probability: 2},\n]\n\nexport const topBottomWidthData = [\n\t{value: 4, probability: 1},\n\t{value: 4.05, probability: 100},\n\t{value: 4.1, probability: 500},\n\t{value: 4.15, probability: 100},\n\t{value: 4.2, probability: 500},\n\t{value: 4.25, probability: 100},\n\t{value: 4.3, probability: 20},\n\t{value: 4.35, probability: 1},\n]\n\nexport const topSegmentShrinkData = [\n\t{value: 0.5, probability: 10},\n\t{value: 0.55, probability: 50},\n\t{value: 0.60, probability: 100},\n\t{value: 0.65, probability: 50},\n\t{value: 0.7, probability: 10},\n]\n\nexport const topShrinkData = [\n\t{value: 0.85, probability: 50},\n\t{value: 0.80, probability: 50},\n\t{value: 0.75, probability: 50},\n]\n\nexport const topHeightData = [\n\t{value: 1.8, probability: 10},\n\t{value: 1.9, probability: 50},\n\t{value: 2, probability: 100},\n\t{value: 2.1, probability: 50},\n\t{value: 2.2, probability: 10},\n]\n\nexport const topRotationData = [\n\t{value: -30, probability: 100},\n\t{value: -20, probability: 100},\n\t{value: -10, probability: 100},\n\t{value: 0, probability: 100},\n\t{value: 10, probability: 100},\n\t{value: 20, probability: 100},\n\t{value: 30, probability: 100},\n]\n\nexport const treeRotationData = [\n\t{value: -10, probability: 1},\n\t{value: -5, probability: 20},\n\t{value: -4, probability: 20},\n\t{value: -3, probability: 20},\n\t{value: -2, probability: 100},\n\t{value: -1, probability: 100},\n\t{value: 0, probability: 500},\n\t{value: 1, probability: 100},\n\t{value: 2, probability: 100},\n\t{value: 3, probability: 20},\n\t{value: 4, probability: 20},\n\t{value: 5, probability: 20},\n\t{value: 10, probability: 1},\n]\n","import {getRandomFloat, getRandomInt} from \"./globalFunctions\"\nimport {\n\ttipHeightData,\n\ttipOffsetData,\n\ttopAmountData,\n\ttopBottomWidthData,\n\ttopColorsData,\n\ttopHeightData,\n\ttopOffset,\n\ttopOffsetData,\n\ttopRotationData,\n\ttopSegmentShrinkData,\n\ttopShrinkData,\n\ttreeRotationData,\n\ttrunkColorsData,\n\ttrunkHeightData,\n\ttrunkSegmentAmountData,\n\ttrunkShrinkData,\n\ttrunkWidthData\n} from \"./dataSets\";\n\nconst dataArrayGenerator = (data) => {\n\tlet array = []\n\tdata.forEach(item => {\n\t\tfor (let i = 0; i < item.probability; i++){\n\t\t\tarray.push(item.value)\n\t\t}\n\t})\n\treturn array\n}\n\nconst generateItemFromDataset = (dataArray) => {\n\tconst generatedArray = dataArrayGenerator(dataArray)\n\treturn (generatedArray[getRandomInt(0, generatedArray.length - 1)])\n}\n\nconst trunkArrayGenerator = (segmentAmount, endPoint) => {\n\tlet pointArray = []\n\tfor (let i = 0; i <= segmentAmount; i++){\n\t\tlet array = [\n\t\t\tgetRandomFloat(0, 0.5).toFixed(2), // x\n\t\t\t((endPoint / segmentAmount) * i).toFixed(2), // y\n\t\t\t0, // z\n\t\t\tgetRandomFloat(0, 100).toFixed(2) // seed\n\t\t]\n\t    pointArray.push(array.join(\"|\"))\n\t}\n\treturn pointArray.join(\",\")\n}\n\nconst topArrayGenerator = (segmentAmount, topSegmentShrink, topShrink) => {\n\tlet segmentArray = []\n\tlet bottomRadius = generateItemFromDataset(topBottomWidthData)\n\tfor (let i = 0; i <= segmentAmount; i++){\n\t\tlet tipHeight = generateItemFromDataset(tipHeightData)\n\t\tlet rotationY = generateItemFromDataset(topRotationData)\n\t\tlet array = [\n\t\t\tbottomRadius,\n\t\t\t(bottomRadius * topSegmentShrink).toFixed(2),\n\t\t\ttipHeight,\n\t\t\trotationY,\n\t\t]\n\t\tsegmentArray.push(array.join(\"|\"))\n\t\tbottomRadius *= topShrink\n\t}\n\treturn segmentArray.join(\",\")\n}\n\nexport const generate = () => {\n\t// trunk\n\tconst trunkColor = generateItemFromDataset(trunkColorsData)\n\tconst trunkWidth = generateItemFromDataset(trunkWidthData)\n\tconst trunkShrink = generateItemFromDataset(trunkShrinkData)\n\tconst trunkArray = trunkArrayGenerator(\n\t\tgenerateItemFromDataset(trunkSegmentAmountData),\n\t\tgenerateItemFromDataset(trunkHeightData),\n\t)\n\n\t// top\n\tconst topColor = generateItemFromDataset(topColorsData)\n\tconst tipHeight = generateItemFromDataset(tipHeightData)\n\tconst tipOffsetX = generateItemFromDataset(tipOffsetData)\n\tconst tipOffsetY = generateItemFromDataset(tipOffsetData)\n\tconst topArray = topArrayGenerator(\n\t\tgenerateItemFromDataset(topAmountData),\n\t\tgenerateItemFromDataset(topSegmentShrinkData),\n\t\tgenerateItemFromDataset(topShrinkData)\n\t)\n\tconst segmentHeight = generateItemFromDataset(topHeightData)\n\tconst topOffsetX = generateItemFromDataset(topOffsetData)\n\tconst topOffsetZ = generateItemFromDataset(topOffsetData)\n\t\n\n\n\t// assembly\n\tconst trunk = [trunkColor, trunkWidth, trunkShrink, trunkArray].join(\"&\")\n\tconst top = [topColor, tipHeight, tipOffsetX, tipOffsetY, topArray, segmentHeight, topOffsetX, topOffsetZ].join(\"&\")\n\treturn [trunk, top].join(\"^\")\n}\n\n\n","import {convertStringToNumber} from \"./globalFunctions\";\n\nconst stringToPointArray = (string) => {\n    let pointArray = []\n    string.split(\",\").forEach(item => {\n        let array = item.split(\"|\")\n        array = array.map(i => parseFloat(i))\n        pointArray.push({\n            x: array[0],\n            y: array[1],\n            z: array[2],\n            seed: array[3],\n        })\n    })\n    return pointArray\n}\n\nconst trunkDecoder = (data) => {\n    const splitData = data.split(\"&\")\n    return ({\n        color: splitData[0],\n        width: parseFloat(splitData[1]),\n        shrink: parseFloat(splitData[2]),\n        pointArray: stringToPointArray(splitData[3])\n    })\n}\n\nconst convertStringToData = (string, trunkTop) => {\n    let data = []\n    string.split(\",\").forEach(item => {\n        item = item.replace(\"x\", trunkTop.x)\n        item = item.replace(\"y\", trunkTop.y)\n        item = item.replace(\"z\", trunkTop.z)\n        let itemArray = item.split(\"|\")\n        itemArray = itemArray.map(i => convertStringToNumber(i))\n        data.push({\n            bottomRadius: itemArray[0],\n            topRadius: itemArray[1],\n            height: itemArray[2],\n            rotationY: itemArray[3],\n        })\n    })\n    return data\n}\n\nconst topDecoder = (string, trunkTop) => {\n    let splitData = string.split(\"&\")\n    return ({\n        color: splitData[0],\n        tipHeight: parseFloat(splitData[1]),\n        tipOffsetX: parseFloat(splitData[2]),\n        tipOffsetZ: parseFloat(splitData[3]),\n        data: convertStringToData(splitData[4], trunkTop),\n        segmentHeight: parseFloat(splitData[5]),\n        topOffsetX: parseFloat(splitData[6]),\n        topOffsetZ: parseFloat(splitData[7])\n    })\n}\n\nexport const decoder = (data, age) => {\n    const splitData = data.split(\"^\")\n    const trunkData = trunkDecoder(splitData[0])\n    const trunkTop = trunkData.pointArray[trunkData.pointArray.length - 1].y\n    const topData = topDecoder(splitData[1], trunkTop)\n    if (age <= 2){\n        const segmentAmount = Math.floor(age * (trunkData.pointArray.length / 10))\n        const totalSegmentAmount = trunkData.pointArray.length\n        trunkData.pointArray = trunkData.pointArray.splice(0, segmentAmount <= totalSegmentAmount ? segmentAmount : totalSegmentAmount)\n        trunkData.color = \"#74a146\"\n        return ({\n            trunkData: trunkData,\n            scale: age / 20\n        })\n    } else {\n        topData.data = topData.data.splice(0, age - 9)\n        return ({\n            topData: topData,\n            trunkData: trunkData,\n            scale: age / 20\n        })\n    }\n}","import {ConeGeometry, Mesh, MeshPhysicalMaterial, Float32BufferAttribute, Group} from \"three\"\nimport {convertVectorsToVertices, convertVerticesToVectors, getRandomFloat} from \"./globalFunctions\"\n\nexport const grass = () => {\n\tconst geometry = new ConeGeometry( 0.05, 1, 3, 4)\n\tconst material = new MeshPhysicalMaterial({color: \"#5c7a3a\", flatShading: true})\n\tconst mesh = new Mesh( geometry, material )\n\n\tlet vertices = convertVerticesToVectors(mesh.geometry.attributes.position.array)\n\tlet heights = vertices.filter((value, index, self) =>\n\t\t\tindex === self.findIndex((t) => (\n\t\t\t\tt.y === value.y\n\t\t\t))\n\t)\n\n\theights = heights.map(height => height.y)\n\n\theights.forEach(y => {\n\t\tlet matchingHeight = vertices.filter(verticle => verticle.y === y)\n\t\tmatchingHeight.forEach(verticle => {\n\t\t\tvertices[vertices.indexOf(verticle)].x += getRandomFloat(-0.05, 0.05)\n\t\t\tvertices[vertices.indexOf(verticle)].z += getRandomFloat(-0.05, 0.05)\n\t\t})\n\t})\n\n\tlet newVertices = convertVectorsToVertices(vertices)\n\tmesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\treturn mesh\n}\n\nexport const grassPatch = (point) => {\n\tconst offsets = [[1,1], [1,-1], [-1, 1], [-1, -1]]\n\tconst group = new Group()\n\tfor (let i = 0; i < 4; i++){\n\t\tlet single = grass()\n\t\tgroup.add(single)\n\t}\n\treturn group\n}\n","import './App.css'\nimport * as React from 'react'\nimport {PerspectiveCamera, Scene, Group, Vector3, Color, BufferAttribute} from 'three'\nimport {useEffect, useRef, useState} from \"react\"\nimport {generateTop} from \"./treeTops\"\nimport {generateTrunk} from \"./trunk\"\nimport {generateModel} from \"./generateModel\"\nimport {BsArrowsMove} from \"react-icons/bs\"\nimport {generate} from \"./generators\"\nimport {createIsland} from \"./island\"\nimport {getRandomFloat, getRandomInt} from \"./globalFunctions\"\nimport {decoder} from \"./decoder\"\nimport {rock} from \"./rock\"\nimport {grass} from \"./grass\"\nimport {MeshSurfaceSampler} from \"three/examples/jsm/math/MeshSurfaceSampler\";\nconst App = () => {\n    const [scene, setScene] = useState(new Scene())\n    const [camera, setCamera] = useState(new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000))\n    const container = useRef(null)\n\n    const growTree = (start, dna, age) => {\n        const {trunkData, topData, scale} = decoder(dna, age)\n        const {trunkMesh, trunkTop} = generateTrunk(scene, trunkData)\n        const topMesh = topData && generateTop(trunkTop, scene, topData)\n        const group = new Group()\n        group.add(trunkMesh)\n        topData && group.add(topMesh)\n        group.position.set(start.x, start.y, start.z)\n        group.scale.set(scale,scale,scale)\n        return {mesh: group, width: topData.data[0].bottomRadius}\n     }\n\n    useEffect(() => {\n        const islandMesh = createIsland(scene, 10)\n        const group = new Group()\n        group.add(islandMesh)\n        islandMesh.translateY(-4)\n\n\n        const sampler = new MeshSurfaceSampler(islandMesh).build()\n        const tempPosition = new Vector3()\n        const meshPositions = []\n\n        let treeCounter = 0\n        while (treeCounter <= 5){\n            sampler.sample(tempPosition)\n            if(new Vector3(0,0,0).distanceTo(tempPosition) < 9){\n                const {mesh, width} = growTree(\n                    tempPosition,\n                    generate(),\n                    getRandomFloat(11, 20)\n                )\n                mesh.translateY(-3)\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < item.width + 1.5)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    meshPositions.push({position: mesh.position, width: width})\n                    treeCounter++\n                }\n            }\n        }\n\n        let rockCounter = 0\n        while (rockCounter <= 20){\n            sampler.sample(tempPosition)\n            let mesh = rock(tempPosition)\n            if (tempPosition.y > -3 && new Vector3(0,0,0).distanceTo(tempPosition) < 9){\n                mesh.position.set(tempPosition.x, tempPosition.y - 3, tempPosition.z);\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < 1)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    meshPositions.push({position: mesh.position, width: 1})\n                    rockCounter++\n                }\n            }\n        }\n\n        const grassModels = []\n        for (let i = 0; i < 10; i++){\n            grassModels.push(grass())\n        }\n        let grassCounter = 0\n        while (grassCounter <= 10){\n            sampler.sample(tempPosition)\n            let mesh = grassModels[getRandomInt(0, 9)].clone()\n            if (tempPosition.y > -3 && new Vector3(0,1,0).distanceTo(tempPosition) < 9.4){\n                mesh.position.set(tempPosition.x, tempPosition.y - 3, tempPosition.z);\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < 0.8)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    grassCounter++\n                }\n            }\n        }\n        scene.add(group)\n        generateModel(scene, setScene, container, camera, setCamera, group)\n    }, [])\n\n    return (\n        <React.Fragment>\n            {window.innerWidth <= 1000 && <BsArrowsMove className={\"moveButton\"}/>}\n            <div ref={container} className={\"container\"}/>\n        </React.Fragment>\n    )\n}\n\nexport default App\n","import {CylinderGeometry, Mesh, Vector3, Group, MeshPhysicalMaterial, Float32BufferAttribute} from \"three\"\nimport {getVertices, updateVertices} from \"./globalFunctions\"\nimport {ConvexGeometry} from \"three/examples/jsm/geometries/ConvexGeometry\"\nimport { makeNoise2D } from \"open-simplex-noise\"\n\nexport const generateTrunk = (scene, data) => {\n    let {color, width, shrink, pointArray} = data\n    let meshArray = []\n    const group = new Group()\n    const material = new MeshPhysicalMaterial({color: parseInt(color.replace(\"#\",\"0x\"),16), flatShading: true})\n\n    pointArray.forEach((point) => {\n        let geometry = new CylinderGeometry(width, width, 0, 12)\n        let mesh = new Mesh(geometry, material)\n        mesh.position.set(point.x, point.y, point.z)\n        mesh.scale.set(1, 1, 1)\n        let vertices = mesh.geometry.attributes.position.array\n        let newVertices = new Float32Array(vertices.length)\n        const noise2D = makeNoise2D(point.seed)\n        for (let i = 0; i <= vertices.length; i += 3) {\n            let p = new Vector3(vertices[i],vertices[i + 1],vertices[i + 2])\n            p.normalize().multiplyScalar(width + 0.2 * noise2D(p.x * 2, p.y * 2))\n            newVertices[i] = p.x\n            newVertices[i + 1] = p.y\n            newVertices[i + 2] = p.z\n        }\n        mesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\n        updateVertices(mesh)\n\n        group.add(mesh)\n        meshArray.push(mesh)\n        width *= shrink\n    })\n\n    for (let i = 1; i < meshArray.length; i++) {\n        let meshes = [meshArray[i - 1], meshArray[i]]\n        let vertices = []\n        meshes.forEach(mesh => {\n            vertices = vertices.concat(getVertices(mesh))\n        })\n        const geometry = new ConvexGeometry( vertices )\n        const mesh = new Mesh( geometry, material )\n\n        group.add( mesh )\n    }\n    return {\n        trunkMesh: group,\n        trunkTop: pointArray[pointArray.length - 1]\n    }\n}\n","import {\n    DodecahedronGeometry,\n    Mesh,\n    MeshPhysicalMaterial,\n    Float32BufferAttribute,\n    BufferAttribute,\n    Color,\n    Vector3\n} from \"three\"\nimport {convertVectorsToVertices, convertVerticesToVectors, getMatchingVertices, getRandomInt} from \"./globalFunctions\"\nimport {makeNoise2D} from \"open-simplex-noise\"\n\nexport const createIsland = (scene, radius) => {\n    const mesh = new Mesh(new DodecahedronGeometry(radius, 10), new MeshPhysicalMaterial({vertexColors: true, flatShading: true}));\n    let vertices = convertVerticesToVectors(mesh.geometry.attributes.position.array)\n    let flatVertices = []\n    vertices.forEach((verticle, i) => {\n        if (verticle.y > -1){\n            let matchingVertices = getMatchingVertices(vertices, i)\n            const y = -1\n            const noise2D = makeNoise2D()\n            matchingVertices.forEach(v => {\n                vertices[v].y = y + (0.2 * noise2D(vertices[v].x * 2, vertices[v].y * 0.4)) * (radius / 3)\n            })\n            flatVertices = flatVertices.concat(matchingVertices)\n        }\n    })\n    mesh.geometry.setAttribute('position', new Float32BufferAttribute(convertVectorsToVertices(vertices), 3))\n\n    const colors = [];\n    const color = new Color();\n    vertices.forEach(verticle => {\n        color.set( [\"#727272\", \"#557312\"][Math.random() > 0.7 ? 0 : 1] );\n\n        colors.push( color.r, color.g, color.b );\n        colors.push( color.r, color.g, color.b );\n        colors.push( color.r, color.g, color.b );\n    })\n    mesh.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n    mesh.translateY(1)\n    return mesh\n}\n","import {OctahedronGeometry, Mesh, MeshPhysicalMaterial, Float32BufferAttribute} from \"three\"\nimport {convertVectorsToVertices, getRandomFloat, getVertices} from \"./globalFunctions\"\nimport {makeNoise3D} from \"open-simplex-noise\";\nexport const rock = () => {\n\tconst mesh = new Mesh(new OctahedronGeometry(3,1), new MeshPhysicalMaterial({color: \"#919191\", flatShading: true}))\n\tconst vertices = getVertices(mesh)\n\tconst noise3D = makeNoise3D(Math.random() * 100)\n\tvertices.forEach(verticle => {\n\t\tconst k = 1\n\t\tverticle.normalize().multiplyScalar(1 + 0.2 * noise3D(verticle.x * k, verticle.y * k, verticle.z * k))\n\t})\n\tconst newVertices = convertVectorsToVertices(vertices)\n\tmesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\n\t// mesh.position.set(point.x, point.y, point.z)\n\tmesh.scale.set(getRandomFloat(0.5,1),0.5,getRandomFloat(0.5,1))\n\treturn mesh\n}\n","import {AmbientLight, DirectionalLight, MOUSE, PerspectiveCamera, Scene, WebGL1Renderer} from \"three\"\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\"\n\nexport const generateModel = (scene, setScene, container, camera, setCamera, group) => {\n    setScene(new Scene())\n\n    //camera\n    setCamera(new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000))\n    camera.position.set( 15, 5, 15 )\n\n    //light\n    const light = new AmbientLight( 0x404040 )\n    scene.add( light )\n    const lights = [\n        {intensity: 1.1, x: 10000, y: 10000, z: 10000},\n        {intensity: 0.1, x: 0, y: 10, z: 10},\n        {intensity: 0.1, x: 10, y: 10, z: -10},\n        {intensity: 0.1, x: -10, y: 10, z: -10},\n        {intensity: 0.4, x: 0, y: -20, z: 0},\n    ]\n    lights.forEach(({intensity, x, y, z}) => {\n        const directionalLight = new DirectionalLight( \"#ffffff\", intensity )\n        directionalLight.position.set(x, y, z)\n        scene.add( directionalLight )\n    })\n    //renderer\n    const renderer = new WebGL1Renderer({alpha: true})\n    renderer.setSize( window.innerWidth, window.innerHeight )\n    container.current.innerHTML = \"\"\n    container.current.appendChild( renderer.domElement )\n\n    //controls\n    let stop = false;\n    const controls = new OrbitControls( camera, renderer.domElement)\n    controls.mouseButtons = {\n        LEFT: MOUSE.ROTATE,\n        MIDDLE: MOUSE.DOLLY,\n        RIGHT: MOUSE.PAN\n    }\n    // controls.minDistance = 25\n    // controls.maxDistance = 200\n    controls.update()\n    controls.addEventListener( 'change', () => {\n        stop = true\n        renderer.render(scene, camera)\n    })\n\n    const animate = () => {\n        if (!stop){\n            requestAnimationFrame(animate)\n            group.rotateY(0.004)\n            renderer.render( scene, camera )\n        }\n    }\n    animate()\n    let image = renderer.domElement.toDataURL()\n    console.log(image)\n    return {image: image}\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}