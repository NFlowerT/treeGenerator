{"version":3,"sources":["globalFunctions.js","App.jsx","treeTops.js","trunk.js","generateModel.js","island.js","decoder.js","rock.js","dataSets.js","generators.js","index.js","grass.js"],"names":["getRandomFloat","min","max","Math","random","getRandomInt","ceil","floor","updateVertices","mesh","updateMatrix","geometry","applyMatrix4","matrix","position","set","rotation","scale","getVertices","verticesArray","vertices","attributes","array","i","length","push","Vector3","convertVerticesToVectors","x","y","z","index","convertVectorsToVertices","vectorArray","sort","a","b","forEach","vector","getMatchingVertices","indexArray","verticle","convertStringToNumber","s","total","replace","match","parseFloat","shift","App","useState","Scene","scene","setScene","PerspectiveCamera","window","innerWidth","innerHeight","camera","setCamera","container","useRef","growTree","start","dna","age","decoder","trunkData","topData","generateTrunk","trunkMesh","trunkTop","topMesh","generateTop","group","Group","add","width","data","bottomRadius","useEffect","islandMesh","createIsland","translateY","sampler","MeshSurfaceSampler","build","tempPosition","meshPositions","treeCounter","sample","distanceTo","generate","check","item","rockCounter","rock","generateModel","process","type","versions","electron","navigator","userAgent","indexOf","className","ref","color","tipHeight","tipOffsetX","tipOffsetZ","segmentHeight","topOffsetX","topOffsetZ","material","MeshPhysicalMaterial","parseInt","flatShading","height","points","THREE","getPoints","previousPoint","point","pointX","pointY","bottomWidth","topWidth","rotationY","lastVerticle","direction","subVectors","orientation","Matrix4","lookAt","Object3D","up","multiply","edgeGeometry","CylinderGeometry","edge","setAttribute","rotateY","cylinderMesh","topRadius","needsUpdate","shrink","pointArray","meshArray","Mesh","newVertices","Float32Array","noise2D","makeNoise2D","seed","p","normalize","multiplyScalar","Float32BufferAttribute","meshes","concat","ConvexGeometry","light","AmbientLight","intensity","directionalLight","DirectionalLight","renderer","WebGL1Renderer","alpha","setSize","current","innerHTML","appendChild","domElement","stop","controls","OrbitControls","mouseButtons","LEFT","MOUSE","ROTATE","MIDDLE","DOLLY","RIGHT","PAN","update","addEventListener","render","animate","requestAnimationFrame","image","toDataURL","console","log","radius","DodecahedronGeometry","vertexColors","flatVertices","matchingVertices","v","colors","Color","r","g","stringToPointArray","string","split","map","convertStringToData","itemArray","splitData","trunkDecoder","topDecoder","segmentAmount","totalSegmentAmount","splice","OctahedronGeometry","noise3D","makeNoise3D","trunkColorsData","value","probability","trunkWidthData","trunkShrinkData","trunkSegmentAmountData","trunkHeightData","topColorsData","tipHeightData","tipOffsetData","topOffsetData","topAmountData","topBottomWidthData","topSegmentShrinkData","topShrinkData","topHeightData","topRotationData","generateItemFromDataset","dataArray","generatedArray","dataArrayGenerator","trunkColor","trunkWidth","trunkShrink","trunkArray","endPoint","toFixed","join","trunkArrayGenerator","topColor","tipOffsetY","topArray","topSegmentShrink","topShrink","segmentArray","topArrayGenerator","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5a176177.chunk.js","sourcesContent":["import {Vector3} from \"three\";\n\nexport const getRandomFloat = (min, max) => {\n    return Math.random() * (max - min) + min\n}\n\nexport const getRandomInt = (min, max) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport const updateVertices = (mesh) => {\n    mesh.updateMatrix()\n    mesh.geometry.applyMatrix4( mesh.matrix )\n    mesh.position.set( 0, 0, 0 )\n    mesh.rotation.set( 0, 0, 0 )\n    mesh.scale.set( 1, 1, 1 )\n    mesh.updateMatrix()\n}\n\nexport const getVertices = (mesh) => {\n    let verticesArray = []\n    let vertices = mesh.geometry.attributes.position.array\n    for (let i = 0; i < (vertices.length - 1); i += 3){\n        verticesArray.push(new Vector3(vertices[i], vertices[i + 1], vertices[i + 2]))\n    }\n    return verticesArray\n}\n\nexport const convertVerticesToVectors = (verticesArray) => {\n    let vertices = []\n    for (let i = 0; i < verticesArray.length; i += 3){\n        vertices.push({x: verticesArray[i], y: verticesArray[i + 1], z: verticesArray[i + 2], index: i})\n    }\n    return vertices\n}\n\nexport const convertVectorsToVertices = (vectorArray) => {\n    let verticesArray = []\n    vectorArray.sort((a, b) => a.index > b.index ? 1 : a.index < b.index ? -1 : 0)\n    vectorArray.forEach((vector) => {\n        verticesArray.push(vector.x, vector.y, vector.z)\n    })\n    return verticesArray\n}\n\nexport const getMatchingVertices = (vertices, index) => {\n    let indexArray = []\n    vertices.forEach((verticle, i) => {\n        if (vertices[index].x === verticle.x && vertices[index].y === verticle.y && vertices[index].z === verticle.z){\n            indexArray.push(i)\n        }\n    })\n    return indexArray\n}\n\nexport const convertStringToNumber = (s) => {\n    let total = 0\n    s = s.replace(/\\s/g, '').match(/[+\\-]?([0-9\\.\\s]+)/g) || []\n    while(s.length) total += parseFloat(s.shift())\n    return total\n}\n","import './App.css'\nimport * as React from 'react'\nimport {PerspectiveCamera, Scene, Group, Vector3, Color, BufferAttribute} from 'three'\nimport {useEffect, useRef, useState} from \"react\"\nimport {generateTop} from \"./treeTops\"\nimport {generateTrunk} from \"./trunk\"\nimport {generateModel} from \"./generateModel\"\nimport {BsArrowsMove} from \"react-icons/bs\"\nimport {generate} from \"./generators\"\nimport {createIsland} from \"./island\"\nimport {getRandomFloat, getRandomInt} from \"./globalFunctions\"\nimport {decoder} from \"./decoder\"\nimport {rock} from \"./rock\"\nimport {grass} from \"./grass\"\nimport {MeshSurfaceSampler} from \"three/examples/jsm/math/MeshSurfaceSampler\"\n\nfunction isElectron() {\n    // Renderer process\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n        return true;\n    }\n\n    // Main process\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\n        return true;\n    }\n\n    // Detect the user agent when the `nodeIntegration` option is set to true\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n        return true;\n    }\n\n    return false;\n}\n\n\nconst App = () => {\n    const [scene, setScene] = useState(new Scene())\n    const [camera, setCamera] = useState(new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000))\n    const container = useRef(null)\n\n    const growTree = (start, dna, age) => {\n        const {trunkData, topData, scale} = decoder(dna, age)\n        const {trunkMesh, trunkTop} = generateTrunk(scene, trunkData)\n        const topMesh = topData && generateTop(trunkTop, scene, topData)\n        const group = new Group()\n        group.add(trunkMesh)\n        topData && group.add(topMesh)\n        group.position.set(start.x, start.y, start.z)\n        group.scale.set(scale,scale,scale)\n        return {mesh: group, width: topData.data[0].bottomRadius}\n     }\n\n    useEffect(() => {\n        const islandMesh = createIsland(scene, 10)\n        const group = new Group()\n        group.add(islandMesh)\n        islandMesh.translateY(-4)\n\n\n        const sampler = new MeshSurfaceSampler(islandMesh).build()\n        const tempPosition = new Vector3()\n        const meshPositions = []\n\n        let treeCounter = 0\n        while (treeCounter <= 5){\n            sampler.sample(tempPosition)\n            if(new Vector3(0,0,0).distanceTo(tempPosition) < 9){\n                const {mesh, width} = growTree(\n                    tempPosition,\n                    generate(),\n                    getRandomFloat(11, 20)\n                )\n                mesh.translateY(-3)\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < item.width + 1.5)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    meshPositions.push({position: mesh.position, width: width})\n                    treeCounter++\n                }\n            }\n        }\n\n        let rockCounter = 0\n        while (rockCounter <= 20){\n            sampler.sample(tempPosition)\n            let mesh = rock(tempPosition)\n            if (tempPosition.y > -3 && new Vector3(0,0,0).distanceTo(tempPosition) < 9){\n                mesh.position.set(tempPosition.x, tempPosition.y - 3, tempPosition.z);\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < 1)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    meshPositions.push({position: mesh.position, width: 1})\n                    rockCounter++\n                }\n            }\n        }\n\n        // const grassModels = []\n        // for (let i = 0; i < 10; i++){\n        //     grassModels.push(grass())\n        // }\n        // let grassCounter = 0\n        // while (grassCounter <= 10){\n        //     sampler.sample(tempPosition)\n        //     let mesh = grassModels[getRandomInt(0, 9)].clone()\n        //     if (tempPosition.y > -3 && new Vector3(0,1,0).distanceTo(tempPosition) < 9.4){\n        //         mesh.position.set(tempPosition.x, tempPosition.y - 3, tempPosition.z);\n        //         let check = true\n        //         meshPositions.forEach(item => {\n        //             if (item.position.distanceTo(mesh.position) < 0.8)\n        //                 check = false\n        //         })\n        //         if (check){\n        //             group.add(mesh)\n        //             grassCounter++\n        //         }\n        //     }\n        // }\n        scene.add(group)\n        generateModel(scene, setScene, container, camera, setCamera, group)\n    }, [])\n\n    return (\n        <React.Fragment>\n            {(isElectron()) && <BsArrowsMove className={\"moveButton\"}/>}\n            <div ref={container} className={\"container\"}/>\n        </React.Fragment>\n    )\n}\n\nexport default App\n","import {\n    CylinderGeometry,\n    Mesh,\n    Group, MeshPhysicalMaterial, Vector3, MeshBasicMaterial, Matrix4, Object3D\n} from \"three\"\nimport {convertVerticesToVectors, getMatchingVertices, convertVectorsToVertices,updateVertices} from \"./globalFunctions\"\nimport * as THREE from \"three\"\n\nconst cylinderMesh = (pointX, pointY, material, bottomWidth, topWidth, rotationY, lastVerticle, tipHeight, tipOffsetX, tipOffsetZ) => {\n    const direction = new Vector3().subVectors(pointY, pointX)\n    const orientation = new Matrix4()\n    orientation.lookAt(pointX, pointY, new Object3D().up)\n    orientation.multiply(new Matrix4().set(1, 0, 0, 0,\n        0, 0, 1, 0,\n        0, -1, 0, 0,\n        0, 0, 0, 1))\n    const edgeGeometry = new CylinderGeometry(topWidth, bottomWidth, direction.length(), 10, 2, false)\n    const edge = new THREE.Mesh(edgeGeometry, material)\n    let vertices = convertVerticesToVectors(edge.geometry.attributes.position.array)\n    vertices.sort((a, b) => a.y > b.y ? 1 : a.y < b.y ? -1 : 0)\n\n    for (let i = 0; i < 11; i += 2){\n        getMatchingVertices(vertices, i).forEach(index => {\n            vertices[index].y -= 0.7\n        })\n    }\n\n    getMatchingVertices(vertices, 20).forEach(index => {\n        vertices[index].y += 1\n    })\n\n    if (lastVerticle){\n        getMatchingVertices(vertices, 60).forEach(index => {\n            vertices[index].y += tipHeight\n            vertices[index].x += tipOffsetX\n            vertices[index].z += tipOffsetZ\n        })\n    }\n    edge.geometry.setAttribute('position', new THREE.Float32BufferAttribute(convertVectorsToVertices(vertices), 3))\n    updateVertices(edge)\n    edge.applyMatrix4(orientation)\n    edge.position.x = (pointY.x + pointX.x) / 2\n    edge.position.y = (pointY.y + pointX.y) / 2\n    edge.position.z = (pointY.z + pointX.z) / 2\n    edge.rotateY(rotationY * 0.0174532925)\n\n    updateVertices(edge)\n\n    return edge\n}\n\nexport const generateTop = (trunkTop, scene, topData) => {\n    let {color, tipHeight, data, tipOffsetX, tipOffsetZ, segmentHeight, topOffsetX, topOffsetZ} = topData\n    const material = new MeshPhysicalMaterial({color: parseInt(color.replace(\"#\",\"0x\"),16), flatShading: true})\n    const group = new Group()\n    const height = data.length * segmentHeight\n    const curve = new THREE.QuadraticBezierCurve3(\n        new THREE.Vector3( trunkTop.x, trunkTop.y, trunkTop.z ),\n        new THREE.Vector3( trunkTop.x - (topOffsetX > 1 ? -1 : topOffsetX), trunkTop.y + (height / 2), trunkTop.z - (topOffsetZ > 1 ? -1 : topOffsetZ) ),\n        new THREE.Vector3( trunkTop.x + topOffsetX, trunkTop.y + height, trunkTop.z + topOffsetZ ),\n    );\n    const points = curve.getPoints(data.length - 1);\n    let previousPoint = null\n    points.forEach((point, i) => {\n        if (previousPoint) {\n            const item = data[i]\n            const topMesh = cylinderMesh(\n                new Vector3(previousPoint.x, previousPoint.y - 0.3, previousPoint.z),\n                point, material, item.bottomRadius, item.topRadius, item.rotationY,\n                i === points.length - 1, tipHeight, tipOffsetX, tipOffsetZ)\n            updateVertices(topMesh)\n            topMesh.geometry.attributes.position.needsUpdate = true\n            group.add( topMesh );\n        }\n        previousPoint = point\n    })\n    group.translateY(-1)\n    return group\n}","import {CylinderGeometry, Mesh, Vector3, Group, MeshPhysicalMaterial, Float32BufferAttribute} from \"three\"\nimport {getVertices, updateVertices} from \"./globalFunctions\"\nimport {ConvexGeometry} from \"three/examples/jsm/geometries/ConvexGeometry\"\nimport { makeNoise2D } from \"open-simplex-noise\"\n\nexport const generateTrunk = (scene, data) => {\n    let {color, width, shrink, pointArray} = data\n    let meshArray = []\n    const group = new Group()\n    const material = new MeshPhysicalMaterial({color: parseInt(color.replace(\"#\",\"0x\"),16), flatShading: true})\n\n    pointArray.forEach((point) => {\n        let geometry = new CylinderGeometry(width, width, 0, 12)\n        let mesh = new Mesh(geometry, material)\n        mesh.position.set(point.x, point.y, point.z)\n        mesh.scale.set(1, 1, 1)\n        let vertices = mesh.geometry.attributes.position.array\n        let newVertices = new Float32Array(vertices.length)\n        const noise2D = makeNoise2D(point.seed)\n        for (let i = 0; i <= vertices.length; i += 3) {\n            let p = new Vector3(vertices[i],vertices[i + 1],vertices[i + 2])\n            p.normalize().multiplyScalar(width + 0.2 * noise2D(p.x * 2, p.y * 2))\n            newVertices[i] = p.x\n            newVertices[i + 1] = p.y\n            newVertices[i + 2] = p.z\n        }\n        mesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\n        updateVertices(mesh)\n\n        group.add(mesh)\n        meshArray.push(mesh)\n        width *= shrink\n    })\n\n    for (let i = 1; i < meshArray.length; i++) {\n        let meshes = [meshArray[i - 1], meshArray[i]]\n        let vertices = []\n        meshes.forEach(mesh => {\n            vertices = vertices.concat(getVertices(mesh))\n        })\n        const geometry = new ConvexGeometry( vertices )\n        const mesh = new Mesh( geometry, material )\n\n        group.add( mesh )\n    }\n    return {\n        trunkMesh: group,\n        trunkTop: pointArray[pointArray.length - 1]\n    }\n}\n","import {AmbientLight, DirectionalLight, MOUSE, PerspectiveCamera, Scene, WebGL1Renderer} from \"three\"\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\"\n\nexport const generateModel = (scene, setScene, container, camera, setCamera, group) => {\n    setScene(new Scene())\n\n    //camera\n    setCamera(new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000))\n    camera.position.set( 20, 0, 20 )\n\n    //light\n    const light = new AmbientLight( 0x404040 )\n    scene.add( light )\n    const lights = [\n        {intensity: 1.1, x: 10000, y: 10000, z: 10000},\n        {intensity: 0.1, x: 0, y: 10, z: 10},\n        {intensity: 0.1, x: 10, y: 10, z: -10},\n        {intensity: 0.1, x: -10, y: 10, z: -10},\n        {intensity: 0.4, x: 0, y: -20, z: 0},\n    ]\n    lights.forEach(({intensity, x, y, z}) => {\n        const directionalLight = new DirectionalLight( \"#ffffff\", intensity )\n        directionalLight.position.set(x, y, z)\n        scene.add( directionalLight )\n    })\n    //renderer\n    const renderer = new WebGL1Renderer({alpha: true})\n    renderer.setSize( window.innerWidth, window.innerHeight )\n    container.current.innerHTML = \"\"\n    container.current.appendChild( renderer.domElement )\n\n    //controls\n    let stop = false;\n    const controls = new OrbitControls( camera, renderer.domElement)\n    controls.mouseButtons = {\n        LEFT: MOUSE.ROTATE,\n        MIDDLE: MOUSE.DOLLY,\n        RIGHT: MOUSE.PAN\n    }\n    // controls.minDistance = 25\n    // controls.maxDistance = 200\n    controls.update()\n    controls.addEventListener( 'change', () => {\n        stop = true\n        renderer.render(scene, camera)\n    })\n\n    const animate = () => {\n        if (!stop){\n            requestAnimationFrame(animate)\n            group.rotateY(0.004)\n            renderer.render( scene, camera )\n        }\n    }\n    animate()\n    let image = renderer.domElement.toDataURL()\n    console.log(image)\n    return {image: image}\n}\n","import {\n    DodecahedronGeometry,\n    Mesh,\n    MeshPhysicalMaterial,\n    Float32BufferAttribute,\n    BufferAttribute,\n    Color,\n    Vector3\n} from \"three\"\nimport {convertVectorsToVertices, convertVerticesToVectors, getMatchingVertices, getRandomInt} from \"./globalFunctions\"\nimport {makeNoise2D} from \"open-simplex-noise\"\n\nexport const createIsland = (scene, radius) => {\n    const mesh = new Mesh(new DodecahedronGeometry(radius, 2), new MeshPhysicalMaterial({vertexColors: true, flatShading: true}));\n    let vertices = convertVerticesToVectors(mesh.geometry.attributes.position.array)\n    let flatVertices = []\n    vertices.forEach((verticle, i) => {\n        if (verticle.y > -1){\n            let matchingVertices = getMatchingVertices(vertices, i)\n            const y = -1\n            const noise2D = makeNoise2D()\n            matchingVertices.forEach(v => {\n                vertices[v].y = y + (0.2 * noise2D(vertices[v].x * 2, vertices[v].y * 0.4)) * (radius / 3)\n            })\n            flatVertices = flatVertices.concat(matchingVertices)\n        }\n    })\n    mesh.geometry.setAttribute('position', new Float32BufferAttribute(convertVectorsToVertices(vertices), 3))\n\n    const colors = [];\n    const color = new Color();\n    vertices.forEach(verticle => {\n        color.set( [\"#727272\", \"#557312\"][Math.random() > 0.7 ? 0 : 1] );\n\n        colors.push( color.r, color.g, color.b );\n        colors.push( color.r, color.g, color.b );\n        colors.push( color.r, color.g, color.b );\n    })\n    mesh.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n    mesh.translateY(1)\n    return mesh\n}\n","import {convertStringToNumber} from \"./globalFunctions\";\n\nconst stringToPointArray = (string) => {\n    let pointArray = []\n    string.split(\",\").forEach(item => {\n        let array = item.split(\"|\")\n        array = array.map(i => parseFloat(i))\n        pointArray.push({\n            x: array[0],\n            y: array[1],\n            z: array[2],\n            seed: array[3],\n        })\n    })\n    return pointArray\n}\n\nconst trunkDecoder = (data) => {\n    const splitData = data.split(\"&\")\n    return ({\n        color: splitData[0],\n        width: parseFloat(splitData[1]),\n        shrink: parseFloat(splitData[2]),\n        pointArray: stringToPointArray(splitData[3])\n    })\n}\n\nconst convertStringToData = (string, trunkTop) => {\n    let data = []\n    string.split(\",\").forEach(item => {\n        item = item.replace(\"x\", trunkTop.x)\n        item = item.replace(\"y\", trunkTop.y)\n        item = item.replace(\"z\", trunkTop.z)\n        let itemArray = item.split(\"|\")\n        itemArray = itemArray.map(i => convertStringToNumber(i))\n        data.push({\n            bottomRadius: itemArray[0],\n            topRadius: itemArray[1],\n            height: itemArray[2],\n            rotationY: itemArray[3],\n        })\n    })\n    return data\n}\n\nconst topDecoder = (string, trunkTop) => {\n    let splitData = string.split(\"&\")\n    return ({\n        color: splitData[0],\n        tipHeight: parseFloat(splitData[1]),\n        tipOffsetX: parseFloat(splitData[2]),\n        tipOffsetZ: parseFloat(splitData[3]),\n        data: convertStringToData(splitData[4], trunkTop),\n        segmentHeight: parseFloat(splitData[5]),\n        topOffsetX: parseFloat(splitData[6]),\n        topOffsetZ: parseFloat(splitData[7])\n    })\n}\n\nexport const decoder = (data, age) => {\n    const splitData = data.split(\"^\")\n    const trunkData = trunkDecoder(splitData[0])\n    const trunkTop = trunkData.pointArray[trunkData.pointArray.length - 1].y\n    const topData = topDecoder(splitData[1], trunkTop)\n    if (age <= 2){\n        const segmentAmount = Math.floor(age * (trunkData.pointArray.length / 10))\n        const totalSegmentAmount = trunkData.pointArray.length\n        trunkData.pointArray = trunkData.pointArray.splice(0, segmentAmount <= totalSegmentAmount ? segmentAmount : totalSegmentAmount)\n        trunkData.color = \"#74a146\"\n        return ({\n            trunkData: trunkData,\n            scale: age / 20\n        })\n    } else {\n        topData.data = topData.data.splice(0, age - 9)\n        return ({\n            topData: topData,\n            trunkData: trunkData,\n            scale: age / 20\n        })\n    }\n}","import {OctahedronGeometry, Mesh, MeshPhysicalMaterial, Float32BufferAttribute} from \"three\"\nimport {convertVectorsToVertices, getRandomFloat, getVertices} from \"./globalFunctions\"\nimport {makeNoise3D} from \"open-simplex-noise\";\nexport const rock = () => {\n\tconst mesh = new Mesh(new OctahedronGeometry(3,1), new MeshPhysicalMaterial({color: \"#919191\", flatShading: true}))\n\tconst vertices = getVertices(mesh)\n\tconst noise3D = makeNoise3D(Math.random() * 100)\n\tvertices.forEach(verticle => {\n\t\tconst k = 1\n\t\tverticle.normalize().multiplyScalar(1 + 0.2 * noise3D(verticle.x * k, verticle.y * k, verticle.z * k))\n\t})\n\tconst newVertices = convertVectorsToVertices(vertices)\n\tmesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\n\t// mesh.position.set(point.x, point.y, point.z)\n\tmesh.scale.set(getRandomFloat(0.5,1),0.5,getRandomFloat(0.5,1))\n\treturn mesh\n}\n","export const trunkColorsData = [\n\t{value: \"#d59168\", probability: 1},\n\t{value: \"#b97952\", probability: 10},\n\t{value: \"#a46239\", probability: 10},\n\t{value: \"#6e3b1c\", probability: 100},\n\t{value: \"#4f2409\", probability: 100},\n\t{value: \"#593e30\", probability: 1000},\n\t{value: \"#52473e\", probability: 1000},\n\t{value: \"#2f1b10\", probability: 1000}\n]\n\nexport const trunkWidthData = [\n\t{value: 0.65, probability: 1},\n\t{value: 0.68, probability: 5},\n\t{value: 0.7, probability: 100},\n\t{value: 0.72, probability: 5},\n\t{value: 0.75, probability: 1},\n]\n\nexport const trunkShrinkData = [\n\t{value: 0.8, probability: 1},\n\t{value: 0.81, probability: 5},\n\t{value: 0.82, probability: 20},\n\t{value: 0.83, probability: 100},\n\t{value: 0.84, probability: 100},\n\t{value: 0.85, probability: 20}\n]\n\nexport const trunkSegmentAmountData = [\n\t{value: 4, probability: 10},\n\t{value: 5, probability: 100},\n\t{value: 6, probability: 100},\n\t{value: 7, probability: 10},\n]\n\nexport const trunkHeightData = [\n\t{value: 4, probability: 100},\n\t{value: 4.5, probability: 50},\n\t{value: 5, probability: 50}\n]\n\nexport const topColorsData = [\n\t{value: \"#b8da67\", probability: 1},\n\t{value: \"#91b341\", probability: 10},\n\t{value: \"#384d10\", probability: 10},\n\t{value: \"#2f3b17\", probability: 100},\n\t{value: \"#99b93e\", probability: 100},\n\t{value: \"#647a26\", probability: 1000},\n\t{value: \"#313b0b\", probability: 1000},\n\t{value: \"#1e2309\", probability: 1000}\n]\n\nexport const tipHeightData = [\n\t{value: 3, probability: 100},\n\t{value: 3.3, probability: 200},\n\t{value: 3.5, probability: 100},\n\t{value: 3.8, probability: 50},\n\t{value: 4, probability: 10},\n]\n\nexport const tipOffsetData = [\n\t{value: 0, probability: 50},\n\t{value: 0.1, probability: 50},\n\t{value: 0.2, probability: 50},\n\t{value: 0.3, probability: 5},\n]\n\nexport const topOffsetData = [\n\t{value: -0.8, probability: 50},\n\t{value: -0.5, probability: 50},\n\t{value: -0.3, probability: 50},\n\t{value: 0, probability: 1000},\n\t{value: 0.3, probability: 50},\n\t{value: 0.5, probability: 50},\n\t{value: 0.8, probability: 50},\n]\n\nexport const topAmountData = [\n\t{value: 3, probability: 200},\n\t{value: 4, probability: 200},\n\t{value: 5, probability: 50},\n\t{value: 6, probability: 10},\n\t{value: 7, probability: 2},\n]\n\nexport const topBottomWidthData = [\n\t{value: 4, probability: 1},\n\t{value: 4.05, probability: 100},\n\t{value: 4.1, probability: 500},\n\t{value: 4.15, probability: 100},\n\t{value: 4.2, probability: 500},\n\t{value: 4.25, probability: 100},\n\t{value: 4.3, probability: 20},\n\t{value: 4.35, probability: 1},\n]\n\nexport const topSegmentShrinkData = [\n\t{value: 0.5, probability: 10},\n\t{value: 0.55, probability: 50},\n\t{value: 0.60, probability: 100},\n\t{value: 0.65, probability: 50},\n\t{value: 0.7, probability: 10},\n]\n\nexport const topShrinkData = [\n\t{value: 0.85, probability: 50},\n\t{value: 0.80, probability: 50},\n\t{value: 0.75, probability: 50},\n]\n\nexport const topHeightData = [\n\t{value: 1.8, probability: 10},\n\t{value: 1.9, probability: 50},\n\t{value: 2, probability: 100},\n\t{value: 2.1, probability: 50},\n\t{value: 2.2, probability: 10},\n]\n\nexport const topRotationData = [\n\t{value: -30, probability: 100},\n\t{value: -20, probability: 100},\n\t{value: -10, probability: 100},\n\t{value: 0, probability: 100},\n\t{value: 10, probability: 100},\n\t{value: 20, probability: 100},\n\t{value: 30, probability: 100},\n]\n\nexport const treeRotationData = [\n\t{value: -10, probability: 1},\n\t{value: -5, probability: 20},\n\t{value: -4, probability: 20},\n\t{value: -3, probability: 20},\n\t{value: -2, probability: 100},\n\t{value: -1, probability: 100},\n\t{value: 0, probability: 500},\n\t{value: 1, probability: 100},\n\t{value: 2, probability: 100},\n\t{value: 3, probability: 20},\n\t{value: 4, probability: 20},\n\t{value: 5, probability: 20},\n\t{value: 10, probability: 1},\n]\n","import {getRandomFloat, getRandomInt} from \"./globalFunctions\"\nimport {\n\ttipHeightData,\n\ttipOffsetData,\n\ttopAmountData,\n\ttopBottomWidthData,\n\ttopColorsData,\n\ttopHeightData,\n\ttopOffset,\n\ttopOffsetData,\n\ttopRotationData,\n\ttopSegmentShrinkData,\n\ttopShrinkData,\n\ttreeRotationData,\n\ttrunkColorsData,\n\ttrunkHeightData,\n\ttrunkSegmentAmountData,\n\ttrunkShrinkData,\n\ttrunkWidthData\n} from \"./dataSets\";\n\nconst dataArrayGenerator = (data) => {\n\tlet array = []\n\tdata.forEach(item => {\n\t\tfor (let i = 0; i < item.probability; i++){\n\t\t\tarray.push(item.value)\n\t\t}\n\t})\n\treturn array\n}\n\nconst generateItemFromDataset = (dataArray) => {\n\tconst generatedArray = dataArrayGenerator(dataArray)\n\treturn (generatedArray[getRandomInt(0, generatedArray.length - 1)])\n}\n\nconst trunkArrayGenerator = (segmentAmount, endPoint) => {\n\tlet pointArray = []\n\tfor (let i = 0; i <= segmentAmount; i++){\n\t\tlet array = [\n\t\t\tgetRandomFloat(0, 0.5).toFixed(2), // x\n\t\t\t((endPoint / segmentAmount) * i).toFixed(2), // y\n\t\t\t0, // z\n\t\t\tgetRandomFloat(0, 100).toFixed(2) // seed\n\t\t]\n\t    pointArray.push(array.join(\"|\"))\n\t}\n\treturn pointArray.join(\",\")\n}\n\nconst topArrayGenerator = (segmentAmount, topSegmentShrink, topShrink) => {\n\tlet segmentArray = []\n\tlet bottomRadius = generateItemFromDataset(topBottomWidthData)\n\tfor (let i = 0; i <= segmentAmount; i++){\n\t\tlet tipHeight = generateItemFromDataset(tipHeightData)\n\t\tlet rotationY = generateItemFromDataset(topRotationData)\n\t\tlet array = [\n\t\t\tbottomRadius,\n\t\t\t(bottomRadius * topSegmentShrink).toFixed(2),\n\t\t\ttipHeight,\n\t\t\trotationY,\n\t\t]\n\t\tsegmentArray.push(array.join(\"|\"))\n\t\tbottomRadius *= topShrink\n\t}\n\treturn segmentArray.join(\",\")\n}\n\nexport const generate = () => {\n\t// trunk\n\tconst trunkColor = generateItemFromDataset(trunkColorsData)\n\tconst trunkWidth = generateItemFromDataset(trunkWidthData)\n\tconst trunkShrink = generateItemFromDataset(trunkShrinkData)\n\tconst trunkArray = trunkArrayGenerator(\n\t\tgenerateItemFromDataset(trunkSegmentAmountData),\n\t\tgenerateItemFromDataset(trunkHeightData),\n\t)\n\n\t// top\n\tconst topColor = generateItemFromDataset(topColorsData)\n\tconst tipHeight = generateItemFromDataset(tipHeightData)\n\tconst tipOffsetX = generateItemFromDataset(tipOffsetData)\n\tconst tipOffsetY = generateItemFromDataset(tipOffsetData)\n\tconst topArray = topArrayGenerator(\n\t\tgenerateItemFromDataset(topAmountData),\n\t\tgenerateItemFromDataset(topSegmentShrinkData),\n\t\tgenerateItemFromDataset(topShrinkData)\n\t)\n\tconst segmentHeight = generateItemFromDataset(topHeightData)\n\tconst topOffsetX = generateItemFromDataset(topOffsetData)\n\tconst topOffsetZ = generateItemFromDataset(topOffsetData)\n\t\n\n\n\t// assembly\n\tconst trunk = [trunkColor, trunkWidth, trunkShrink, trunkArray].join(\"&\")\n\tconst top = [topColor, tipHeight, tipOffsetX, tipOffsetY, topArray, segmentHeight, topOffsetX, topOffsetZ].join(\"&\")\n\treturn [trunk, top].join(\"^\")\n}\n\n\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n","import {ConeGeometry, Mesh, MeshPhysicalMaterial, Float32BufferAttribute, Group} from \"three\"\nimport {convertVectorsToVertices, convertVerticesToVectors, getRandomFloat} from \"./globalFunctions\"\n\nexport const grass = () => {\n\tconst geometry = new ConeGeometry( 0.05, 1, 3, 4)\n\tconst material = new MeshPhysicalMaterial({color: \"#5c7a3a\", flatShading: true})\n\tconst mesh = new Mesh( geometry, material )\n\n\tlet vertices = convertVerticesToVectors(mesh.geometry.attributes.position.array)\n\tlet heights = vertices.filter((value, index, self) =>\n\t\t\tindex === self.findIndex((t) => (\n\t\t\t\tt.y === value.y\n\t\t\t))\n\t)\n\n\theights = heights.map(height => height.y)\n\n\theights.forEach(y => {\n\t\tlet matchingHeight = vertices.filter(verticle => verticle.y === y)\n\t\tmatchingHeight.forEach(verticle => {\n\t\t\tvertices[vertices.indexOf(verticle)].x += getRandomFloat(-0.05, 0.05)\n\t\t\tvertices[vertices.indexOf(verticle)].z += getRandomFloat(-0.05, 0.05)\n\t\t})\n\t})\n\n\tlet newVertices = convertVectorsToVertices(vertices)\n\tmesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\treturn mesh\n}\n\nexport const grassPatch = (point) => {\n\tconst offsets = [[1,1], [1,-1], [-1, 1], [-1, -1]]\n\tconst group = new Group()\n\tfor (let i = 0; i < 4; i++){\n\t\tlet single = grass()\n\t\tgroup.add(single)\n\t}\n\treturn group\n}\n"],"sourceRoot":""}