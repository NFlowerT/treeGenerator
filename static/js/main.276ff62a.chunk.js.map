{"version":3,"sources":["globalFunctions.js","treeTops.js","dataSets.js","generators.js","decoder.js","App.jsx","trunk.js","island.js","rock.js","generateModel.js","index.js"],"names":["getRandomFloat","min","max","Math","random","updateVertices","mesh","updateMatrix","geometry","applyMatrix4","matrix","position","set","rotation","scale","getVertices","verticesArray","vertices","attributes","array","i","length","push","Vector3","convertVerticesToVectors","x","y","z","index","convertVectorsToVertices","vectorArray","sort","a","b","forEach","vector","getMatchingVertices","indexArray","verticle","generateTop","trunkTop","scene","topData","color","tipHeight","data","tipOffsetX","tipOffsetZ","segmentHeight","topOffsetX","topOffsetZ","material","MeshPhysicalMaterial","parseInt","replace","flatShading","group","Group","height","points","THREE","getPoints","previousPoint","point","item","topMesh","pointX","pointY","bottomWidth","topWidth","rotationY","lastVerticle","direction","subVectors","orientation","Matrix4","lookAt","Object3D","up","multiply","edgeGeometry","CylinderGeometry","edge","setAttribute","rotateY","cylinderMesh","bottomRadius","topRadius","needsUpdate","add","translateY","trunkColorsData","value","probability","trunkWidthData","trunkShrinkData","trunkSegmentAmountData","trunkHeightData","topColorsData","tipHeightData","tipOffsetData","topOffsetData","topAmountData","topBottomWidthData","topSegmentShrinkData","topShrinkData","topHeightData","topRotationData","generateItemFromDataset","dataArray","generatedArray","dataArrayGenerator","ceil","floor","generate","trunkColor","trunkWidth","trunkShrink","trunkArray","segmentAmount","endPoint","pointArray","toFixed","join","trunkArrayGenerator","topColor","tipOffsetY","topArray","topSegmentShrink","topShrink","segmentArray","topArrayGenerator","stringToPointArray","string","split","map","parseFloat","seed","convertStringToData","itemArray","s","total","match","shift","convertStringToNumber","decoder","age","splitData","trunkData","width","shrink","trunkDecoder","topDecoder","totalSegmentAmount","splice","App","useState","Scene","setScene","PerspectiveCamera","window","innerWidth","innerHeight","camera","setCamera","container","useRef","growTree","start","dna","meshArray","Mesh","newVertices","Float32Array","noise2D","makeNoise2D","p","normalize","multiplyScalar","Float32BufferAttribute","meshes","concat","ConvexGeometry","trunkMesh","generateTrunk","useEffect","islandMesh","radius","DodecahedronGeometry","vertexColors","flatVertices","matchingVertices","v","colors","Color","r","g","createIsland","sampler","MeshSurfaceSampler","build","tempPosition","meshPositions","treeCounter","sample","distanceTo","check","rockCounter","OctahedronGeometry","noise3D","makeNoise3D","rock","light","AmbientLight","intensity","directionalLight","DirectionalLight","renderer","WebGL1Renderer","alpha","setSize","current","innerHTML","appendChild","domElement","stop","controls","OrbitControls","mouseButtons","LEFT","MOUSE","ROTATE","MIDDLE","DOLLY","RIGHT","PAN","update","addEventListener","render","animate","requestAnimationFrame","image","toDataURL","console","log","generateModel","className","ref","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.276ff62a.chunk.js","sourcesContent":["import {Vector3} from \"three\";\n\nexport const getRandomFloat = (min, max) => {\n    return Math.random() * (max - min) + min\n}\n\nexport const getRandomInt = (min, max) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport const updateVertices = (mesh) => {\n    mesh.updateMatrix()\n    mesh.geometry.applyMatrix4( mesh.matrix )\n    mesh.position.set( 0, 0, 0 )\n    mesh.rotation.set( 0, 0, 0 )\n    mesh.scale.set( 1, 1, 1 )\n    mesh.updateMatrix()\n}\n\nexport const getVertices = (mesh) => {\n    let verticesArray = []\n    let vertices = mesh.geometry.attributes.position.array\n    for (let i = 0; i < (vertices.length - 1); i += 3){\n        verticesArray.push(new Vector3(vertices[i], vertices[i + 1], vertices[i + 2]))\n    }\n    return verticesArray\n}\n\nexport const convertVerticesToVectors = (verticesArray) => {\n    let vertices = []\n    for (let i = 0; i < verticesArray.length; i += 3){\n        vertices.push({x: verticesArray[i], y: verticesArray[i + 1], z: verticesArray[i + 2], index: i})\n    }\n    return vertices\n}\n\nexport const convertVectorsToVertices = (vectorArray) => {\n    let verticesArray = []\n    vectorArray.sort((a, b) => a.index > b.index ? 1 : a.index < b.index ? -1 : 0)\n    vectorArray.forEach((vector) => {\n        verticesArray.push(vector.x, vector.y, vector.z)\n    })\n    return verticesArray\n}\n\nexport const getMatchingVertices = (vertices, index) => {\n    let indexArray = []\n    vertices.forEach((verticle, i) => {\n        if (vertices[index].x === verticle.x && vertices[index].y === verticle.y && vertices[index].z === verticle.z){\n            indexArray.push(i)\n        }\n    })\n    return indexArray\n}\n\nexport const convertStringToNumber = (s) => {\n    let total = 0\n    s = s.replace(/\\s/g, '').match(/[+\\-]?([0-9\\.\\s]+)/g) || []\n    while(s.length) total += parseFloat(s.shift())\n    return total\n}\n","import {\n    CylinderGeometry,\n    Mesh,\n    Group, MeshPhysicalMaterial, Vector3, MeshBasicMaterial, Matrix4, Object3D\n} from \"three\"\nimport {convertVerticesToVectors, getMatchingVertices, convertVectorsToVertices,updateVertices} from \"./globalFunctions\"\nimport * as THREE from \"three\"\n\nconst cylinderMesh = (pointX, pointY, material, bottomWidth, topWidth, rotationY, lastVerticle, tipHeight, tipOffsetX, tipOffsetZ) => {\n    const direction = new Vector3().subVectors(pointY, pointX)\n    const orientation = new Matrix4()\n    orientation.lookAt(pointX, pointY, new Object3D().up)\n    orientation.multiply(new Matrix4().set(1, 0, 0, 0,\n        0, 0, 1, 0,\n        0, -1, 0, 0,\n        0, 0, 0, 1))\n    const edgeGeometry = new CylinderGeometry(topWidth, bottomWidth, direction.length(), 10, 2, false)\n    const edge = new THREE.Mesh(edgeGeometry, material)\n    let vertices = convertVerticesToVectors(edge.geometry.attributes.position.array)\n    vertices.sort((a, b) => a.y > b.y ? 1 : a.y < b.y ? -1 : 0)\n\n    for (let i = 0; i < 11; i += 2){\n        getMatchingVertices(vertices, i).forEach(index => {\n            vertices[index].y -= 0.7\n        })\n    }\n\n    getMatchingVertices(vertices, 20).forEach(index => {\n        vertices[index].y += 1\n    })\n\n    if (lastVerticle){\n        getMatchingVertices(vertices, 60).forEach(index => {\n            vertices[index].y += tipHeight\n            vertices[index].x += tipOffsetX\n            vertices[index].z += tipOffsetZ\n        })\n    }\n    edge.geometry.setAttribute('position', new THREE.Float32BufferAttribute(convertVectorsToVertices(vertices), 3))\n    updateVertices(edge)\n    edge.applyMatrix4(orientation)\n    edge.position.x = (pointY.x + pointX.x) / 2\n    edge.position.y = (pointY.y + pointX.y) / 2\n    edge.position.z = (pointY.z + pointX.z) / 2\n    edge.rotateY(rotationY * 0.0174532925)\n\n    updateVertices(edge)\n\n    return edge\n}\n\nexport const generateTop = (trunkTop, scene, topData) => {\n    let {color, tipHeight, data, tipOffsetX, tipOffsetZ, segmentHeight, topOffsetX, topOffsetZ} = topData\n    const material = new MeshPhysicalMaterial({color: parseInt(color.replace(\"#\",\"0x\"),16), flatShading: true})\n    const group = new Group()\n    const height = data.length * segmentHeight\n    const curve = new THREE.QuadraticBezierCurve3(\n        new THREE.Vector3( trunkTop.x, trunkTop.y, trunkTop.z ),\n        new THREE.Vector3( trunkTop.x - (topOffsetX > 1 ? -1 : topOffsetX), trunkTop.y + (height / 2), trunkTop.z - (topOffsetZ > 1 ? -1 : topOffsetZ) ),\n        new THREE.Vector3( trunkTop.x + topOffsetX, trunkTop.y + height, trunkTop.z + topOffsetZ ),\n    );\n    const points = curve.getPoints(data.length - 1);\n    let previousPoint = null\n    points.forEach((point, i) => {\n        if (previousPoint) {\n            const item = data[i]\n            const topMesh = cylinderMesh(\n                new Vector3(previousPoint.x, previousPoint.y - 0.3, previousPoint.z),\n                point, material, item.bottomRadius, item.topRadius, item.rotationY,\n                i === points.length - 1, tipHeight, tipOffsetX, tipOffsetZ)\n            updateVertices(topMesh)\n            topMesh.geometry.attributes.position.needsUpdate = true\n            group.add( topMesh );\n        }\n        previousPoint = point\n    })\n    group.translateY(-1)\n    return group\n}","export const trunkColorsData = [\n\t{value: \"#d59168\", probability: 1},\n\t{value: \"#b97952\", probability: 10},\n\t{value: \"#a46239\", probability: 10},\n\t{value: \"#6e3b1c\", probability: 100},\n\t{value: \"#4f2409\", probability: 100},\n\t{value: \"#593e30\", probability: 1000},\n\t{value: \"#52473e\", probability: 1000},\n\t{value: \"#2f1b10\", probability: 1000}\n]\n\nexport const trunkWidthData = [\n\t{value: 0.65, probability: 1},\n\t{value: 0.68, probability: 5},\n\t{value: 0.7, probability: 100},\n\t{value: 0.72, probability: 5},\n\t{value: 0.75, probability: 1},\n]\n\nexport const trunkShrinkData = [\n\t{value: 0.8, probability: 1},\n\t{value: 0.81, probability: 5},\n\t{value: 0.82, probability: 20},\n\t{value: 0.83, probability: 100},\n\t{value: 0.84, probability: 100},\n\t{value: 0.85, probability: 20}\n]\n\nexport const trunkSegmentAmountData = [\n\t{value: 4, probability: 10},\n\t{value: 5, probability: 100},\n\t{value: 6, probability: 100},\n\t{value: 7, probability: 10},\n]\n\nexport const trunkHeightData = [\n\t{value: 4, probability: 100},\n\t{value: 4.5, probability: 50},\n\t{value: 5, probability: 50}\n]\n\nexport const topColorsData = [\n\t{value: \"#b8da67\", probability: 1},\n\t{value: \"#91b341\", probability: 10},\n\t{value: \"#384d10\", probability: 10},\n\t{value: \"#2f3b17\", probability: 100},\n\t{value: \"#99b93e\", probability: 100},\n\t{value: \"#647a26\", probability: 1000},\n\t{value: \"#313b0b\", probability: 1000},\n\t{value: \"#1e2309\", probability: 1000}\n]\n\nexport const tipHeightData = [\n\t{value: 3, probability: 100},\n\t{value: 3.3, probability: 200},\n\t{value: 3.5, probability: 100},\n\t{value: 3.8, probability: 50},\n\t{value: 4, probability: 10},\n]\n\nexport const tipOffsetData = [\n\t{value: 0, probability: 50},\n\t{value: 0.1, probability: 50},\n\t{value: 0.2, probability: 50},\n\t{value: 0.3, probability: 5},\n]\n\nexport const topOffsetData = [\n\t{value: -0.8, probability: 50},\n\t{value: -0.5, probability: 50},\n\t{value: -0.3, probability: 50},\n\t{value: 0, probability: 1000},\n\t{value: 0.3, probability: 50},\n\t{value: 0.5, probability: 50},\n\t{value: 0.8, probability: 50},\n]\n\nexport const topAmountData = [\n\t{value: 3, probability: 200},\n\t{value: 4, probability: 200},\n\t{value: 5, probability: 50},\n\t{value: 6, probability: 10},\n\t{value: 7, probability: 2},\n]\n\nexport const topBottomWidthData = [\n\t{value: 4, probability: 1},\n\t{value: 4.05, probability: 100},\n\t{value: 4.1, probability: 500},\n\t{value: 4.15, probability: 100},\n\t{value: 4.2, probability: 500},\n\t{value: 4.25, probability: 100},\n\t{value: 4.3, probability: 20},\n\t{value: 4.35, probability: 1},\n]\n\nexport const topSegmentShrinkData = [\n\t{value: 0.5, probability: 10},\n\t{value: 0.55, probability: 50},\n\t{value: 0.60, probability: 100},\n\t{value: 0.65, probability: 50},\n\t{value: 0.7, probability: 10},\n]\n\nexport const topShrinkData = [\n\t{value: 0.85, probability: 50},\n\t{value: 0.80, probability: 50},\n\t{value: 0.75, probability: 50},\n]\n\nexport const topHeightData = [\n\t{value: 1.8, probability: 10},\n\t{value: 1.9, probability: 50},\n\t{value: 2, probability: 100},\n\t{value: 2.1, probability: 50},\n\t{value: 2.2, probability: 10},\n]\n\nexport const topRotationData = [\n\t{value: -30, probability: 100},\n\t{value: -20, probability: 100},\n\t{value: -10, probability: 100},\n\t{value: 0, probability: 100},\n\t{value: 10, probability: 100},\n\t{value: 20, probability: 100},\n\t{value: 30, probability: 100},\n]\n\nexport const treeRotationData = [\n\t{value: -10, probability: 1},\n\t{value: -5, probability: 20},\n\t{value: -4, probability: 20},\n\t{value: -3, probability: 20},\n\t{value: -2, probability: 100},\n\t{value: -1, probability: 100},\n\t{value: 0, probability: 500},\n\t{value: 1, probability: 100},\n\t{value: 2, probability: 100},\n\t{value: 3, probability: 20},\n\t{value: 4, probability: 20},\n\t{value: 5, probability: 20},\n\t{value: 10, probability: 1},\n]\n","import {getRandomFloat, getRandomInt} from \"./globalFunctions\"\nimport {\n\ttipHeightData,\n\ttipOffsetData,\n\ttopAmountData,\n\ttopBottomWidthData,\n\ttopColorsData,\n\ttopHeightData,\n\ttopOffset,\n\ttopOffsetData,\n\ttopRotationData,\n\ttopSegmentShrinkData,\n\ttopShrinkData,\n\ttreeRotationData,\n\ttrunkColorsData,\n\ttrunkHeightData,\n\ttrunkSegmentAmountData,\n\ttrunkShrinkData,\n\ttrunkWidthData\n} from \"./dataSets\";\n\nconst dataArrayGenerator = (data) => {\n\tlet array = []\n\tdata.forEach(item => {\n\t\tfor (let i = 0; i < item.probability; i++){\n\t\t\tarray.push(item.value)\n\t\t}\n\t})\n\treturn array\n}\n\nconst generateItemFromDataset = (dataArray) => {\n\tconst generatedArray = dataArrayGenerator(dataArray)\n\treturn (generatedArray[getRandomInt(0, generatedArray.length - 1)])\n}\n\nconst trunkArrayGenerator = (segmentAmount, endPoint) => {\n\tlet pointArray = []\n\tfor (let i = 0; i <= segmentAmount; i++){\n\t\tlet array = [\n\t\t\tgetRandomFloat(0, 0.5).toFixed(2), // x\n\t\t\t((endPoint / segmentAmount) * i).toFixed(2), // y\n\t\t\t0, // z\n\t\t\tgetRandomFloat(0, 100).toFixed(2) // seed\n\t\t]\n\t    pointArray.push(array.join(\"|\"))\n\t}\n\treturn pointArray.join(\",\")\n}\n\nconst topArrayGenerator = (segmentAmount, topSegmentShrink, topShrink) => {\n\tlet segmentArray = []\n\tlet bottomRadius = generateItemFromDataset(topBottomWidthData)\n\tfor (let i = 0; i <= segmentAmount; i++){\n\t\tlet tipHeight = generateItemFromDataset(tipHeightData)\n\t\tlet rotationY = generateItemFromDataset(topRotationData)\n\t\tlet array = [\n\t\t\tbottomRadius,\n\t\t\t(bottomRadius * topSegmentShrink).toFixed(2),\n\t\t\ttipHeight,\n\t\t\trotationY,\n\t\t]\n\t\tsegmentArray.push(array.join(\"|\"))\n\t\tbottomRadius *= topShrink\n\t}\n\treturn segmentArray.join(\",\")\n}\n\nexport const generate = () => {\n\t// trunk\n\tconst trunkColor = generateItemFromDataset(trunkColorsData)\n\tconst trunkWidth = generateItemFromDataset(trunkWidthData)\n\tconst trunkShrink = generateItemFromDataset(trunkShrinkData)\n\tconst trunkArray = trunkArrayGenerator(\n\t\tgenerateItemFromDataset(trunkSegmentAmountData),\n\t\tgenerateItemFromDataset(trunkHeightData),\n\t)\n\n\t// top\n\tconst topColor = generateItemFromDataset(topColorsData)\n\tconst tipHeight = generateItemFromDataset(tipHeightData)\n\tconst tipOffsetX = generateItemFromDataset(tipOffsetData)\n\tconst tipOffsetY = generateItemFromDataset(tipOffsetData)\n\tconst topArray = topArrayGenerator(\n\t\tgenerateItemFromDataset(topAmountData),\n\t\tgenerateItemFromDataset(topSegmentShrinkData),\n\t\tgenerateItemFromDataset(topShrinkData)\n\t)\n\tconst segmentHeight = generateItemFromDataset(topHeightData)\n\tconst topOffsetX = generateItemFromDataset(topOffsetData)\n\tconst topOffsetZ = generateItemFromDataset(topOffsetData)\n\t\n\n\n\t// assembly\n\tconst trunk = [trunkColor, trunkWidth, trunkShrink, trunkArray].join(\"&\")\n\tconst top = [topColor, tipHeight, tipOffsetX, tipOffsetY, topArray, segmentHeight, topOffsetX, topOffsetZ].join(\"&\")\n\treturn [trunk, top].join(\"^\")\n}\n\n\n","import {convertStringToNumber} from \"./globalFunctions\";\n\nconst stringToPointArray = (string) => {\n    let pointArray = []\n    string.split(\",\").forEach(item => {\n        let array = item.split(\"|\")\n        array = array.map(i => parseFloat(i))\n        pointArray.push({\n            x: array[0],\n            y: array[1],\n            z: array[2],\n            seed: array[3],\n        })\n    })\n    return pointArray\n}\n\nconst trunkDecoder = (data) => {\n    const splitData = data.split(\"&\")\n    return ({\n        color: splitData[0],\n        width: parseFloat(splitData[1]),\n        shrink: parseFloat(splitData[2]),\n        pointArray: stringToPointArray(splitData[3])\n    })\n}\n\nconst convertStringToData = (string, trunkTop) => {\n    let data = []\n    string.split(\",\").forEach(item => {\n        item = item.replace(\"x\", trunkTop.x)\n        item = item.replace(\"y\", trunkTop.y)\n        item = item.replace(\"z\", trunkTop.z)\n        let itemArray = item.split(\"|\")\n        itemArray = itemArray.map(i => convertStringToNumber(i))\n        data.push({\n            bottomRadius: itemArray[0],\n            topRadius: itemArray[1],\n            height: itemArray[2],\n            rotationY: itemArray[3],\n        })\n    })\n    return data\n}\n\nconst topDecoder = (string, trunkTop) => {\n    let splitData = string.split(\"&\")\n    return ({\n        color: splitData[0],\n        tipHeight: parseFloat(splitData[1]),\n        tipOffsetX: parseFloat(splitData[2]),\n        tipOffsetZ: parseFloat(splitData[3]),\n        data: convertStringToData(splitData[4], trunkTop),\n        segmentHeight: parseFloat(splitData[5]),\n        topOffsetX: parseFloat(splitData[6]),\n        topOffsetZ: parseFloat(splitData[7])\n    })\n}\n\nexport const decoder = (data, age) => {\n    const splitData = data.split(\"^\")\n    const trunkData = trunkDecoder(splitData[0])\n    const trunkTop = trunkData.pointArray[trunkData.pointArray.length - 1].y\n    const topData = topDecoder(splitData[1], trunkTop)\n    if (age <= 2){\n        const segmentAmount = Math.floor(age * (trunkData.pointArray.length / 10))\n        const totalSegmentAmount = trunkData.pointArray.length\n        trunkData.pointArray = trunkData.pointArray.splice(0, segmentAmount <= totalSegmentAmount ? segmentAmount : totalSegmentAmount)\n        trunkData.color = \"#74a146\"\n        return ({\n            trunkData: trunkData,\n            scale: age / 20\n        })\n    } else {\n        topData.data = topData.data.splice(0, age - 9)\n        return ({\n            topData: topData,\n            trunkData: trunkData,\n            scale: age / 20\n        })\n    }\n}","import './App.css'\nimport * as React from 'react'\nimport {PerspectiveCamera, Scene, Group, Vector3, Color, BufferAttribute} from 'three'\nimport {useEffect, useRef, useState} from \"react\"\nimport {generateTop} from \"./treeTops\"\nimport {generateTrunk} from \"./trunk\"\nimport {generateModel} from \"./generateModel\"\nimport {BsArrowsMove} from \"react-icons/bs\"\nimport {generate} from \"./generators\"\nimport {createIsland} from \"./island\"\nimport {getRandomFloat, getRandomInt} from \"./globalFunctions\"\nimport {decoder} from \"./decoder\"\nimport {rock} from \"./rock\"\nimport {grass} from \"./grass\"\nimport {MeshSurfaceSampler} from \"three/examples/jsm/math/MeshSurfaceSampler\";\nconst App = () => {\n    const [scene, setScene] = useState(new Scene())\n    const [camera, setCamera] = useState(new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000))\n    const container = useRef(null)\n\n    const growTree = (start, dna, age) => {\n        const {trunkData, topData, scale} = decoder(dna, age)\n        const {trunkMesh, trunkTop} = generateTrunk(scene, trunkData)\n        const topMesh = topData && generateTop(trunkTop, scene, topData)\n        const group = new Group()\n        group.add(trunkMesh)\n        topData && group.add(topMesh)\n        group.position.set(start.x, start.y, start.z)\n        group.scale.set(scale,scale,scale)\n        return {mesh: group, width: topData.data[0].bottomRadius}\n     }\n\n    useEffect(() => {\n        const islandMesh = createIsland(scene, 10)\n        const group = new Group()\n        group.add(islandMesh)\n        islandMesh.translateY(-4)\n\n\n        const sampler = new MeshSurfaceSampler(islandMesh).build()\n        const tempPosition = new Vector3()\n        const meshPositions = []\n\n        let treeCounter = 0\n        while (treeCounter <= 5){\n            sampler.sample(tempPosition)\n            if(new Vector3(0,0,0).distanceTo(tempPosition) < 9){\n                const {mesh, width} = growTree(\n                    tempPosition,\n                    generate(),\n                    getRandomFloat(11, 20)\n                )\n                mesh.translateY(-3)\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < item.width + 1.5)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    meshPositions.push({position: mesh.position, width: width})\n                    treeCounter++\n                }\n            }\n        }\n\n        let rockCounter = 0\n        while (rockCounter <= 20){\n            sampler.sample(tempPosition)\n            let mesh = rock(tempPosition)\n            if (tempPosition.y > -3 && new Vector3(0,0,0).distanceTo(tempPosition) < 9){\n                mesh.position.set(tempPosition.x, tempPosition.y - 3, tempPosition.z);\n                let check = true\n                meshPositions.forEach(item => {\n                    if (item.position.distanceTo(mesh.position) < 1)\n                        check = false\n                })\n                if (check){\n                    group.add(mesh)\n                    meshPositions.push({position: mesh.position, width: 1})\n                    rockCounter++\n                }\n            }\n        }\n\n        // const grassModels = []\n        // for (let i = 0; i < 10; i++){\n        //     grassModels.push(grass())\n        // }\n        // let grassCounter = 0\n        // while (grassCounter <= 10){\n        //     sampler.sample(tempPosition)\n        //     let mesh = grassModels[getRandomInt(0, 9)].clone()\n        //     if (tempPosition.y > -3 && new Vector3(0,1,0).distanceTo(tempPosition) < 9.4){\n        //         mesh.position.set(tempPosition.x, tempPosition.y - 3, tempPosition.z);\n        //         let check = true\n        //         meshPositions.forEach(item => {\n        //             if (item.position.distanceTo(mesh.position) < 0.8)\n        //                 check = false\n        //         })\n        //         if (check){\n        //             group.add(mesh)\n        //             grassCounter++\n        //         }\n        //     }\n        // }\n        scene.add(group)\n        generateModel(scene, setScene, container, camera, setCamera, group)\n    }, [])\n\n    return (\n        <React.Fragment>\n            {window.innerWidth <= 1000 && <BsArrowsMove className={\"moveButton\"}/>}\n            <div ref={container} className={\"container\"}/>\n        </React.Fragment>\n    )\n}\n\nexport default App\n","import {CylinderGeometry, Mesh, Vector3, Group, MeshPhysicalMaterial, Float32BufferAttribute} from \"three\"\nimport {getVertices, updateVertices} from \"./globalFunctions\"\nimport {ConvexGeometry} from \"three/examples/jsm/geometries/ConvexGeometry\"\nimport { makeNoise2D } from \"open-simplex-noise\"\n\nexport const generateTrunk = (scene, data) => {\n    let {color, width, shrink, pointArray} = data\n    let meshArray = []\n    const group = new Group()\n    const material = new MeshPhysicalMaterial({color: parseInt(color.replace(\"#\",\"0x\"),16), flatShading: true})\n\n    pointArray.forEach((point) => {\n        let geometry = new CylinderGeometry(width, width, 0, 12)\n        let mesh = new Mesh(geometry, material)\n        mesh.position.set(point.x, point.y, point.z)\n        mesh.scale.set(1, 1, 1)\n        let vertices = mesh.geometry.attributes.position.array\n        let newVertices = new Float32Array(vertices.length)\n        const noise2D = makeNoise2D(point.seed)\n        for (let i = 0; i <= vertices.length; i += 3) {\n            let p = new Vector3(vertices[i],vertices[i + 1],vertices[i + 2])\n            p.normalize().multiplyScalar(width + 0.2 * noise2D(p.x * 2, p.y * 2))\n            newVertices[i] = p.x\n            newVertices[i + 1] = p.y\n            newVertices[i + 2] = p.z\n        }\n        mesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\n        updateVertices(mesh)\n\n        group.add(mesh)\n        meshArray.push(mesh)\n        width *= shrink\n    })\n\n    for (let i = 1; i < meshArray.length; i++) {\n        let meshes = [meshArray[i - 1], meshArray[i]]\n        let vertices = []\n        meshes.forEach(mesh => {\n            vertices = vertices.concat(getVertices(mesh))\n        })\n        const geometry = new ConvexGeometry( vertices )\n        const mesh = new Mesh( geometry, material )\n\n        group.add( mesh )\n    }\n    return {\n        trunkMesh: group,\n        trunkTop: pointArray[pointArray.length - 1]\n    }\n}\n","import {\n    DodecahedronGeometry,\n    Mesh,\n    MeshPhysicalMaterial,\n    Float32BufferAttribute,\n    Color,\n} from \"three\"\nimport {convertVectorsToVertices, convertVerticesToVectors, getMatchingVertices} from \"./globalFunctions\"\nimport {makeNoise2D} from \"open-simplex-noise\"\n\nexport const createIsland = (scene, radius) => {\n    const mesh = new Mesh(new DodecahedronGeometry(radius, 6), new MeshPhysicalMaterial({vertexColors: true, flatShading: true}));\n    let vertices = convertVerticesToVectors(mesh.geometry.attributes.position.array)\n    let flatVertices = []\n    vertices.forEach((verticle, i) => {\n        if (verticle.y > -1){\n            let matchingVertices = getMatchingVertices(vertices, i)\n            const y = -1\n            const noise2D = makeNoise2D()\n            matchingVertices.forEach(v => {\n                vertices[v].y = y + (0.4 * noise2D(vertices[v].x * 0.2, vertices[v].y * 0.3)) * (radius / 4)\n            })\n            flatVertices = flatVertices.concat(matchingVertices)\n        }\n    })\n    mesh.geometry.setAttribute('position', new Float32BufferAttribute(convertVectorsToVertices(vertices), 3))\n\n    const colors = []\n    const color = new Color()\n    vertices.forEach(() => {\n        color.set( [\"#727272\", \"#557312\"][Math.random() > 0.7 ? 0 : 1] )\n        colors.push( color.r, color.g, color.b )\n        colors.push( color.r, color.g, color.b )\n        colors.push( color.r, color.g, color.b )\n    })\n    mesh.geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) )\n    mesh.translateY(1)\n    return mesh\n}\n","import {OctahedronGeometry, Mesh, MeshPhysicalMaterial, Float32BufferAttribute} from \"three\"\nimport {convertVectorsToVertices, getRandomFloat, getVertices} from \"./globalFunctions\"\nimport {makeNoise3D} from \"open-simplex-noise\";\nexport const rock = () => {\n\tconst mesh = new Mesh(new OctahedronGeometry(3,1), new MeshPhysicalMaterial({color: \"#919191\", flatShading: true}))\n\tconst vertices = getVertices(mesh)\n\tconst noise3D = makeNoise3D(Math.random() * 100)\n\tvertices.forEach(verticle => {\n\t\tconst k = 1\n\t\tverticle.normalize().multiplyScalar(1 + 0.2 * noise3D(verticle.x * k, verticle.y * k, verticle.z * k))\n\t})\n\tconst newVertices = convertVectorsToVertices(vertices)\n\tmesh.geometry.setAttribute('position', new Float32BufferAttribute(newVertices, 3))\n\n\t// mesh.position.set(point.x, point.y, point.z)\n\tmesh.scale.set(getRandomFloat(0.5,1),0.5,getRandomFloat(0.5,1))\n\treturn mesh\n}\n","import {AmbientLight, DirectionalLight, MOUSE, PerspectiveCamera, Scene, WebGL1Renderer} from \"three\"\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\"\n\nexport const generateModel = (scene, setScene, container, camera, setCamera, group) => {\n    setScene(new Scene())\n\n    //camera\n    setCamera(new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000))\n    camera.position.set( 20, 5, 20 )\n\n    //light\n    const light = new AmbientLight( 0x404040 )\n    scene.add( light )\n    const lights = [\n        {intensity: 1.1, x: 10000, y: 10000, z: 10000},\n        {intensity: 0.1, x: 0, y: 10, z: 10},\n        {intensity: 0.1, x: 10, y: 10, z: -10},\n        {intensity: 0.1, x: -10, y: 10, z: -10},\n        {intensity: 0.4, x: 0, y: -20, z: 0},\n    ]\n    lights.forEach(({intensity, x, y, z}) => {\n        const directionalLight = new DirectionalLight( \"#ffffff\", intensity )\n        directionalLight.position.set(x, y, z)\n        scene.add( directionalLight )\n    })\n    //renderer\n    const renderer = new WebGL1Renderer({alpha: true})\n    renderer.setSize( window.innerWidth, window.innerHeight )\n    container.current.innerHTML = \"\"\n    container.current.appendChild( renderer.domElement )\n\n    //controls\n    let stop = false;\n    const controls = new OrbitControls( camera, renderer.domElement)\n    controls.mouseButtons = {\n        LEFT: MOUSE.ROTATE,\n        MIDDLE: MOUSE.DOLLY,\n        RIGHT: MOUSE.PAN\n    }\n    // controls.minDistance = 25\n    // controls.maxDistance = 200\n    controls.update()\n    controls.addEventListener( 'change', () => {\n        stop = true\n        renderer.render(scene, camera)\n    })\n\n    const animate = () => {\n        if (!stop){\n            requestAnimationFrame(animate)\n            group.rotateY(0.004)\n            renderer.render( scene, camera )\n        }\n    }\n    animate()\n    let image = renderer.domElement.toDataURL()\n    console.log(image)\n    return {image: image}\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}